% !TeX root = RJwrapper.tex
\title{Programmatic Generation of R Markdown Documents with
\pkg{listdown}}
\author{by Michael Kane}

\maketitle

\abstract{%
An abstract of less than 150 words.
}

\hypertarget{background-and-concepts}{%
\section{Background and concepts}\label{background-and-concepts}}

R Markdown documents support the construction of reproducible documents
by allowing authors to insert R code for data processing, exploration,
analysis, table-making, and visualization directly into structured,
prose documents. In the context of this document, we will refer to the R
code in these documents as \emph{computational components} since they
are generated by computational means (namely the R interpreter). The
prose in these documents will be referred to as \emph{narrative
components}. They may serve to help a reader understand the background,
goal, theme, and results of the paper as well as contextualizing the
computational components.

R Markdown \citep{baumer2014} integrates the process of integrating the
computational and narrative components of a document. By itself this is
not novel. It was identified as ``Literate Programming'' by
\citet{knuth1984} and software tools, like Sweave \citep{leisch2002}
have supported this functionality for almost two decades. R Markdown's
popularity has likely been driven by two factors. The first is the
relative ease with which these documents can be constructed. While it is
more expressive, \LaTeX is relatively technical and requires an
investment in time to become proficient. By contrast R Markdown
documents are easier to create and format and, when the document is used
to create \LaTeX formatting can be passed through to the underlying .tex
file. The second factor driving adoption is likely its support for
creating \emph{modifiable} documents, Microsoft Word in particular.
Researchers and analysts, especially those creating applied statistical
analyses, often collaborate with domain experts with less technical
knowledge. In these cases, the analyst focuses on creating the
computational components and narrative components related to results and
interpretation. After this initial document is created, the domain
expert is free to develop narrative components directly in the document
without needing to go through the analyst.

Since computational components are, by definition, computationally
derived objects and R Markdown is a well-defined standard it is possible
to programmatically create R Markdown documents with computational
components. This is the focus of this paper. However, before proceeding
down this avenue, we would like to highlight two fundamental limitations
to automated R Markdown document construction. First and foremost,
without narrative components a document has no context. Quantitative
analyses require research questions, hypotheses, reviews,
interpretations, and conclusions. Computational components are necessary
but not sufficient for constructing an analysis. Second, it is not
possible to construct computational components for an arbitary set of
distinct analyses. An analysis itself has a context and it is built with
a set of assumptions and goals. Computational components are constructed
for a narrow class of problems.

However, this is not to say the programmatic creation of R Markdown
documents is unwarranted or not useful. In fact it has at least two
appealing characteristics. The first is convenience. \textless FILL THIS
IN - TALK ABOUT REUSE TO MOTIVATE LARGER PIPELINES\textgreater. The
second is that for fixed analysis pipelines processing
uniformly-formatted but domain-distinct data, automated document
generation enforces uniformity across those domains being serviced. .

The \pkg{listdown} package provides functions to programmatically create
R Markdown files from named lists. It is intended for data analysis
pipelines where the presentation of the results is separated from their
creation. For this use case, a data processing (or analysis) is
performed and the results are provided in a single named list, organized
heirarchically. With the list and a \pkg{listdown} object a workflowr
\citep{blischak2019}, pdf, word, or html page. List element names denote
sections, subsections, subsubsection, etc. and the list elements contain
the data structure to be presented including graphs and tables. The goal
of the package is not to provide a finished, readable document. It is to
provide a document with all tables and visualization that will appear
(\emph{computational} components). This serves as a starting point from
which a user can organize outputs, describe a study, discuss results,
and provide conclusions (\emph{narrative} components).

\pkg{listdown} provides a reproducible means for producing a document
with specified computational components. It is most compatible with data
analysis pipelines where the data format is fixed but the analyses are
either being updated, which may affect narrative components including
the result discussion and conclusion, or where the experiment is
different, which affects all narrative components If the narrative
components are not changing with the data being pushed through your
analysis pipeline, then you may be better off writing the R Markdown
code manually.

The package itself is relatively simple with 6 distinct methods that can
be easily incorporated into existing analysis pipelines for
automatically creating documents that can be used for data exploration
and reviewing analysis results as well as a starting point for a more
formal write up. These methods include:

\begin{itemize}
\item{\bf ld\_chunk\_opts() }{- apply chunk options to a presentation object}
\item{\bf ld\_ioslides\_header() }{- create an ioslides presentation header}
\item{\bf ld\_make\_chunks() }{- write a listdown object to a string}
\item{\bf ld\_workflowr\_header() }{- create a worflowr header}
\item{\bf ld\_rmarkdown\_header() }{- create an R Markdown header}
\item{\bf listdown() }{- create a listdown object to create an R Markdown document}
\item{\bf to\_data\_tree() }{- create a data.tree object from a list of computational components}
\end{itemize}

The rest of this paper is structured as follow. The next section goes
over basic usage and commentary. This section is meant to convey the
basic approach used by the package and shows how to describe an output
document using \pkg{listdown}, create a document, and change how the
presentation of computational components can be specialized using
\pkg{listdown} decorators. With the user accustomed to the package's
basic usage, section 3 describes the design of the package. Section 4
goes over advanced usage of the package including adding initialization
code to and outputted document as well as how to control chunk-level
options. Section 5 concludes the paper with a few final remarks.

\hypertarget{basic-usage-and-overview}{%
\section{Basic usage and overview}\label{basic-usage-and-overview}}

Suppose we have just completed and analysis and have collected all of
the results into a list where the list elements are roughly in the order
we would like to present them in a document. It may be noted that this
is not always how computational components derived from data analyses
are collated. Often individual components are stored in multiple
locations on a single machine or across machines. However, it is
important to realize that even for analyses on large-scale data, the
digital artifact that will be presented will be relatively small.
Centralizing them makes it easier to access them, since they don't need
to be found in mulitple locations. Also, storing them as a list provides
a hierarchical structure that translates directly to a document as we
will see below.

As a first example, we will consider the a list of visualizations from
the anscombe data set. The list is composed of four \pkg{ggplot2}
\citep{wickham2016}elements (named Linear, Non Linear, Outlier Vertical,
and Outlier Horizontal) each containing a scatter plot from the famous
Anscome Quartet - made available in the \pkg{datasets} package
\citep{R}. From the \texttt{computational\_components} list, we would
like to create a document with four sections with names corresponding to
the list names, each containing their respective visualizations.

\begin{Schunk}
\begin{Sinput}
# Use ggplot2 to create the visualizations.
library(ggplot2)

# Load the Anscombe Quartet.
data(anscombe)

# Create the ggplot objects to display.
  computational_components <- list(
    Linear = ggplot(anscombe, aes(x = x1, y = y1)) + geom_point(),
    `Non Linear` = ggplot(anscombe, aes(x = x2, y = y2)) + geom_point(),
    `Outlier Vertical`= ggplot(anscombe, aes(x = x3, y = y3)) + geom_point(),
    `Outlier Horizontal` =  ggplot(anscombe, aes(x = x4, y = y4)) + geom_point())

# Save the file to disk to be read by the output R Markdown document.
saveRDS(computational_components, "comp-comp.rds")
\end{Sinput}
\end{Schunk}

\hypertarget{creating-a-document-with}{%
\subsection{\texorpdfstring{Creating a document with
\pkg{listdown}}{Creating a document with }}\label{creating-a-document-with}}

Creating a document from the \texttt{computational\_components} will
require two steps. First, we will create a \texttt{listdown} object that
specifies how the \texttt{computational\_components} object will be
loaded into the document, which libraries and code needs to be included,
the options for the R chunks, and how the list elements will be
presented in the output R markdown document.

\begin{Schunk}
\begin{Sinput}
library(listdown)

ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"), # The expression to load pres_list in the .Rmd.
               package = "ggplot2")                     # The packges needed to render plots.
\end{Sinput}
\end{Schunk}

The \texttt{ld} object, along with the computational components in the
\texttt{comp-comp.rds} file are sufficient to to create the sections,
subsections, and R chunks of a document. The only other thing requires
to create the document is the header. The listdown package currently
supports regular R Markdown, workflowr, and ioslides headers. A complete
document can then be written to the console using the code shown below.
It could easily be written to a file for rendering using the
\texttt{writeLines()} function, for example.

\begin{Schunk}
\begin{Sinput}
doc <- c(
  ld_rmarkdown_header("Anscombe's Quartet",
                     author = "Francis Anscombe",
                     date = "1973"),
  ld_make_chunks(ld))

cat(paste(doc, collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> ---
#> title: "Anscombe's Quartet"
#> author: "Francis Anscombe"
#> date: "1973"
#> output: html_document
#> ---
#> 
#> ```{r}
#> library(ggplot2)
#> 
#> cc_list <- readRDS("comp-comp.rds")
#> ```
#> 
#> # Linear
#> 
#> ```{r}
#> identity(cc_list[[1]])
#> ```
#> 
#> # Non Linear
#> 
#> ```{r}
#> identity(cc_list[[2]])
#> ```
#> 
#> # Outlier Vertical
#> 
#> ```{r}
#> identity(cc_list[[3]])
#> ```
#> 
#> # Outlier Horizontal
#> 
#> ```{r}
#> identity(cc_list[[4]])
#> ```
\end{Soutput}
\end{Schunk}

The \texttt{listdown()} function provides \emph{document-wide} R chunk
options for displaying computational components. The chunk options are
exactly the same as those in the R markdown document and can be used to
tailor the default presentation for a variety of needs. The complete set
of options can be found in the
\href{https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf}{R
Markdown Reference Guide}. As a concrete example, the code used to
create present the plots could be hidden in the output document using
the following code.

\begin{Schunk}
\begin{Sinput}
ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"), 
               package = "ggplot2",
               echo = FALSE)

cat(paste(ld_make_chunks(ld)[1:7], collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> 
#> ```{r echo=FALSE}
#> library(ggplot2)
#> 
#> cc_list <- readRDS("comp-comp.rds")
#> ```
\end{Soutput}
\end{Schunk}

\hypertarget{decorators}{%
\subsection{Decorators}\label{decorators}}

The first example is simple in part because the ggplot objects both
contain the data we want to display and, at the same time, provide the
mechanism for presenting them - rendering them in a graph. However, this
is not always the case. The objects being stored in the list of
computational components may not translate directly to the presentation
in a document. In these cases a function is needed that takes the list
component and returns an object to be displayed. For example, suppose
that, along with showing graphs from the Anscombe Quartet, we would like
to include the data themselves. We could add the data to the
\texttt{computational\_components} list and then create the document
with:

\begin{Schunk}
\begin{Sinput}
computational_components$Data <- anscombe
saveRDS(computational_components, "comp-comp.rds")
cat(paste(ld_make_chunks(ld)[32:36], collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> # Data
#> 
#> ```{r echo=FALSE}
#> identity(cc_list[[5]])
#> ```
\end{Soutput}
\end{Schunk}

In this case, the \pkg{listdown} package will show the entire data set
as is the default specified. However, suppose we do not want to show the
entire data set in the document. This is common, especially when the
data set is large and requires too much vertical space in the outputted
document resulting in too much or irrelevant data being shown. Instead,
we would like to output to an html document where the data is shown in a
datatable thereby controlling the amount of real-estate needed to
present the data and, at the same time, providing the user with
interactivity to sort and search the data set.

In \pkg{listdown} a function or method that implments the presentation
of a computational component is referred to as a \emph{decorator} since
if follows the classic decorator pattern described in \citet{gamma1995}.
A decorator takes the element that will be presented as an argument and
returns an object for presentation in the output directory. A decorator
is specified using the \texttt{decorator} parameter of the
\texttt{listdown()} function using a named list where the name
corresponds to the type and the element correspond to the function or
method that will decorate an object of that type. For example, the
\texttt{anscombe} data set can be decorated with the
\texttt{DT::datatable()} function \citep{xie2020} as:

\begin{Schunk}
\begin{Sinput}
ld <- listdown(load_cc_expr = readRDS("comp-comp.rds"), 
               package = c("ggplot2", "DT"),
               decorator = list(data.frame = datatable))
cat(paste(ld_make_chunks(ld)[33:37], collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> # Data
#> 
#> ```{r}
#> datatable(cc_list[[5]])
#> ```
\end{Soutput}
\end{Schunk}

List names in the \texttt{decorator} argument provide a key to which a
function or method is mapped. The underlying decorator resolution is
implemented for a given computational component by going through
decorator names sequentially to see if the component inherits from the
name using the \texttt{inherits()} function. The function or method is
selected from the corresponding name which the element first inherits
from. This means that when customizing the presentation of objects that
inherit from a common class, the more abstract classes should appear at
the end of the list. This will ensure that specialized classes will be
encountered first in the resolution process.

A separate argument, \texttt{default\_decorator}, allows the user to
specify the default decorator for an object whose type does not appear
in the \texttt{decorator} list. This allows the user to specify any
class name for the decorator and avoids a potential type name collision
with a default decorator whose name is determined by convention. By
default, this argument is set to \texttt{identity} but it can be use to
not display a computational component by default if the argument is set
to \texttt{NULL}.

\hypertarget{design}{%
\section{Design}\label{design}}

A \pkg{listdown} object specifies the location of a list of
computational components and options for presenting those components in
an R Markdown document. The list is a hierarchical data structure that
also provides the structure of the outputted document. A corresponding
document has two sections ``Iris'' and ``Sepal.Length''. The latter has
three subsections ``Sepal.Width'', ``Petal.Length'', and ``Colored''.
The ``Colored'' subsection has two sub-subsections, ``Sepal.Width'' and
``Petal.Length''. The structure can be seen using the
\texttt{ld\_cc\_dendro()} function.

\begin{Schunk}
\begin{Sinput}
# Create a more hierarchical list of computational components.
comp_comp2 <- list(
  Iris = iris,
  Sepal.Length = list(
    Sepal.Width = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(),
    Petal.Length = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(),
    Colored = list(
      Sepal.Width = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
        geom_point(),
      Petal.Length = ggplot(iris, aes(x = Sepal.Length, y = Petal.Length, color = Species)) + 
        geom_point())))

# Create the dendrogram.
ld_cc_dendro(comp_comp2)
\end{Sinput}
\begin{Soutput}
#> 
#>  comp_comp2
#>   |-- Iris
#>   |  °-- object of type(s):data.frame
#>   °-- Sepal.Length
#>    |-- Sepal.Width
#>    |  °-- object of type(s):gg ggplot
#>    |-- Petal.Length
#>    |  °-- object of type(s):gg ggplot
#>    °-- Colored
#>     |-- Sepal.Width
#>     |  °-- object of type(s):gg ggplot
#>     °-- Petal.Length
#>        °-- object of type(s):gg ggplot 
#> 
\end{Soutput}
\end{Schunk}

Both the \texttt{ld\_cc\_dendro()} and \texttt{ld\_make\_chunks()}
functions work by recursively descending the computational components
list depth-first. If the list containing and element has a name, it is
written to the output as a section, subsection, subsubsection, etc. to a
return string. If the visited list element is itself a list, then the
same procedure is called on the child list through a recursive call. If
the element is not a list, then it is outputted inside an R Markdown
chunk in the return string using the appropropriate decorator.

\hypertarget{advanced-usage}{%
\section{Advanced usage}\label{advanced-usage}}

Along with the basic usage, the \pkg{listdown} package supports methods
to further customize the presentation. Two specific areas of
customization are addressed. The first is where custom code is required
either to modify decorators or even define the decorators. In this case,
we would to add a small portion of code, immediately after loading
required libraries. In the second case, rather than changing the R code
inside of a chunk, we would like to change the options for an individual
chunk. Both of these features are supported in the package and are
presented below.

\hypertarget{initialization-code}{%
\subsection{Initialization code}\label{initialization-code}}

\begin{Schunk}
\begin{Sinput}
saveRDS(comp_comp2, "comp-comp2.rds")
ld <- listdown(load_cc_expr = readRDS("comp-comp2.rds"),
               package = c("ggplot2", "DT", "purrr"),
               decorator = list(ggplot = identity,
                                data.frame = datatable),
               init_expr = {
                 datatable <- partial(datatable,
                                      options = list(dom = 't'))
                 },
               echo = FALSE)

cat(paste(ld_make_chunks(ld)[1:13], collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> 
#> ```{r echo=FALSE}
#> library(ggplot2)
#> library(DT)
#> library(purrr)
#> 
#> cc_list <- readRDS("comp-comp2.rds")
#> ```
#> 
#> ```{r echo=FALSE}
#> datatable <- partial(datatable, options = list(dom = "t"))
#> ```
\end{Soutput}
\end{Schunk}

\hypertarget{controlling-chunk-level-options}{%
\subsection{Controlling chunk-level
options}\label{controlling-chunk-level-options}}

Along with providing document-wide chunk options, it is also possible to
control individual chunk options

\begin{Schunk}
\begin{Sinput}
comp_comp2$Iris <- ld_chunk_opts(comp_comp2$Iris, echo = TRUE)
saveRDS(comp_comp2, "comp-comp2.rds")
cat(paste(ld_make_chunks(ld)[1:19], collapse = "\n"))
\end{Sinput}
\begin{Soutput}
#> 
#> ```{r echo=FALSE}
#> library(ggplot2)
#> library(DT)
#> library(purrr)
#> 
#> cc_list <- readRDS("comp-comp2.rds")
#> ```
#> 
#> ```{r echo=FALSE}
#> datatable <- partial(datatable, options = list(dom = "t"))
#> ```
#> 
#> # Iris
#> 
#> ```{r echo = TRUE}
#> datatable(cc_list[[1]])
#> ```
\end{Soutput}
\end{Schunk}

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

\bibliography{RJreferences}


\address{%
Michael Kane\\
Yale University\\
60 College Street\\ New Haven, CT 06510, USA\\
}
\href{mailto:michael.kane@yale.edu}{\nolinkurl{michael.kane@yale.edu}}
